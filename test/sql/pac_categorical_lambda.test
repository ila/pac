# name: test/sql/pac_categorical_lambda.test
# description: Test PAC categorical lambda-based rewriting - demonstrates arbitrary boolean expressions
# group: [sql]

# The lambda-based categorical rewrite allows arbitrary boolean expressions involving
# a PAC aggregate, not just simple comparisons like "value > pac_agg".
#
# This enables expressions like:
# - WHERE NOT (value > pac_agg)
# - WHERE (value + offset) > pac_agg
# - WHERE pac_agg * factor > threshold

require pac

# ============================================================================
# Schema Setup
# ============================================================================

statement ok
CREATE TABLE products (
    product_id INTEGER PRIMARY KEY,
    product_name VARCHAR,
    base_price DECIMAL(10,2),
    category VARCHAR
);

statement ok
CREATE TABLE customers (
    customer_id INTEGER PRIMARY KEY,
    customer_name VARCHAR,
    region VARCHAR
);

statement ok
CREATE TABLE sales (
    sale_id INTEGER PRIMARY KEY,
    product_id INTEGER,
    customer_id INTEGER,
    quantity INTEGER,
    sale_price DECIMAL(10,2),
    sale_date DATE,
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

# ============================================================================
# Test Data
# ============================================================================

statement ok
INSERT INTO customers VALUES
    (1, 'Alice', 'North'),
    (2, 'Bob', 'South'),
    (3, 'Carol', 'North'),
    (4, 'David', 'East'),
    (5, 'Eve', 'West');

statement ok
INSERT INTO products VALUES
    (1, 'Widget A', 10.00, 'Widgets'),
    (2, 'Widget B', 20.00, 'Widgets'),
    (3, 'Gadget X', 50.00, 'Gadgets'),
    (4, 'Gadget Y', 100.00, 'Gadgets'),
    (5, 'Tool Z', 30.00, 'Tools');

statement ok
INSERT INTO sales VALUES
    -- Product 1 sales (total qty: 100, avg: 20)
    (1, 1, 1, 20, 10.00, '2024-01-15'),
    (2, 1, 2, 30, 10.00, '2024-01-20'),
    (3, 1, 3, 25, 10.00, '2024-02-10'),
    (4, 1, 4, 15, 10.00, '2024-02-15'),
    (5, 1, 5, 10, 10.00, '2024-03-01'),
    -- Product 2 sales (total qty: 80, avg: 16)
    (6, 2, 1, 15, 20.00, '2024-01-18'),
    (7, 2, 2, 25, 20.00, '2024-02-05'),
    (8, 2, 3, 20, 20.00, '2024-02-20'),
    (9, 2, 4, 10, 20.00, '2024-03-10'),
    (10, 2, 5, 10, 20.00, '2024-03-15'),
    -- Product 3 sales (total qty: 50, avg: 10)
    (11, 3, 1, 10, 50.00, '2024-01-25'),
    (12, 3, 2, 15, 50.00, '2024-02-12'),
    (13, 3, 3, 10, 50.00, '2024-02-28'),
    (14, 3, 4, 10, 50.00, '2024-03-05'),
    (15, 3, 5, 5, 50.00, '2024-03-20'),
    -- Product 4 sales (total qty: 30, avg: 6)
    (16, 4, 1, 5, 100.00, '2024-01-30'),
    (17, 4, 2, 8, 100.00, '2024-02-15'),
    (18, 4, 3, 7, 100.00, '2024-03-01'),
    (19, 4, 4, 5, 100.00, '2024-03-12'),
    (20, 4, 5, 5, 100.00, '2024-03-25'),
    -- Product 5 sales (total qty: 60, avg: 12)
    (21, 5, 1, 12, 30.00, '2024-02-01'),
    (22, 5, 2, 18, 30.00, '2024-02-18'),
    (23, 5, 3, 10, 30.00, '2024-03-05'),
    (24, 5, 4, 12, 30.00, '2024-03-18'),
    (25, 5, 5, 8, 30.00, '2024-03-28');

# ============================================================================
# PAC Configuration
# ============================================================================

statement ok
ALTER TABLE customers SET PAC;

statement ok
SET pac_seed = 42;

statement ok
SET pac_deterministic_noise = true;

statement ok
SET threads = 1;

statement ok
SET pac_mi = 0;

# Verify pac_mi is set correctly
query I
SELECT current_setting('pac_mi');
----
0.0

# ============================================================================
# Test 1: NOT operator with comparison
# Find products where it's NOT true that avg quantity per sale > 15
# With pac_noised, the PAC aggregate returns a single noised value which is
# compared normally. Results differ from exact due to PAC subsampling.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    NOT (
        (SELECT avg(s.quantity) FROM sales s WHERE s.product_id = p.product_id) > 15
    )
ORDER BY p.product_id;
----
4	Gadget Y

# ============================================================================
# Test 2: Arithmetic on PAC aggregate result (multiplication)
# Find products where (total_qty * 0.5) > 40
# With pac_noised, the noised sum is used directly in the comparison.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT sum(s.quantity) FROM sales s WHERE s.product_id = p.product_id) * 0.5 > 40
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
5	Tool Z

# ============================================================================
# Test 3: Arithmetic on scalar side
# Find products where base_price * 5 > avg(sale_quantity)
# All products pass this comparison
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    p.base_price * 5 > (
        SELECT avg(s.quantity)
        FROM sales s
        WHERE s.product_id = p.product_id
    )
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
4	Gadget Y
5	Tool Z

# ============================================================================
# Test 4: Nested arithmetic expressions on scalar
# Find products where (base_price + 10) * 2 > sum(quantity)
# With pac_noised, the noised sum is compared against the scalar expression.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (p.base_price + 10) * 2 > (
        SELECT sum(s.quantity)
        FROM sales s
        WHERE s.product_id = p.product_id
    )
ORDER BY p.product_id;
----
3	Gadget X
4	Gadget Y

# ============================================================================
# Test 5: Greater than or equal comparison
# Find products where total qty >= 60
# With pac_noised, the noised sum is compared normally.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT sum(s.quantity) FROM sales s WHERE s.product_id = p.product_id) >= 60
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
4	Gadget Y
5	Tool Z

# ============================================================================
# Test 6: Less than or equal comparison
# Find products where avg qty <= 10
# With pac_noised, the noised avg is compared normally.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT avg(s.quantity) FROM sales s WHERE s.product_id = p.product_id) <= 10
ORDER BY p.product_id;
----

# ============================================================================
# Test 7: Equality comparison
# Find products where count of sales equals 5 (all products have 5 sales each)
# Equality on noised values rarely matches exactly.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT count(*) FROM sales s WHERE s.product_id = p.product_id) = 5
ORDER BY p.product_id;
----

# ============================================================================
# Test 8: Inequality (not equal)
# Find products where total quantity is not equal to 60
# With pac_noised, the noised sum is compared normally.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT sum(s.quantity) FROM sales s WHERE s.product_id = p.product_id) <> 60
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
5	Tool Z

# ============================================================================
# Test 9: Cast expression in comparison - DISABLED
# This test is disabled because cast on PAC aggregate causes internal error
# Find products where total qty (as integer) > 75
# Products: 1 (100), 2 (80)
# ============================================================================

# ============================================================================
# Test 10: Double NOT (negation of negation)
# Find products where it's NOT NOT true that avg > 15 (should equal avg > 15)
# With pac_noised, the noised avg is compared normally.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    NOT NOT (
        (SELECT avg(s.quantity) FROM sales s WHERE s.product_id = p.product_id) > 15
    )
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
5	Tool Z

# ============================================================================
# Test 11: Comparison with division on aggregate
# Find products where (sum / 10) >= base_price
# With pac_noised, the noised sum is used in the division.
# ============================================================================

query I
SELECT count(*) FROM (
    SELECT p.product_id
    FROM products p
    WHERE
        (SELECT sum(s.quantity) FROM sales s WHERE s.product_id = p.product_id) / 10.0 >= p.base_price
);
----
1

# ============================================================================
# Test 12: Comparison with subtraction
# Find products where (sum - 50) > 0
# With pac_noised, the noised sum is used in the subtraction.
# ============================================================================

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT sum(s.quantity) FROM sales s WHERE s.product_id = p.product_id) - 50 > 0
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
3	Gadget X
4	Gadget Y
5	Tool Z

# ============================================================================
# Test 13: Multi-aggregate filter - comparing two sums
# Find products where sum(quantity) > sum(sale_price)/5
# This tests filter with two PAC aggregates (list_zip + list_transform + pac_noised)
# Product 1: 100 > 50/5=10? YES
# Product 2: 80 > 100/5=20? YES
# Product 3: 50 > 250/5=50? NO
# Product 4: 30 > 500/5=100? NO
# Product 5: 60 > 150/5=30? YES
# ============================================================================

# Verify the rewriter uses pac_sum_counters, list_zip, list_transform, and pac_noised
query I nosort explain_test13
EXPLAIN SELECT p.product_id, p.product_name FROM products p
WHERE (SELECT sum(s.quantity) FROM sales s, customers c WHERE s.product_id = p.product_id AND s.customer_id = c.customer_id) >
      (SELECT sum(s.sale_price) / 5.0 FROM sales s, customers c WHERE s.product_id = p.product_id AND s.customer_id = c.customer_id)
ORDER BY p.product_id;
----
pac_sum_counters
list_zip
list_transform
pac_noised

query II
SELECT
    p.product_id,
    p.product_name
FROM
    products p
WHERE
    (SELECT sum(s.quantity) FROM sales s, customers c WHERE s.product_id = p.product_id AND s.customer_id = c.customer_id) >
    (SELECT sum(s.sale_price) / 5.0 FROM sales s, customers c WHERE s.product_id = p.product_id AND s.customer_id = c.customer_id)
ORDER BY p.product_id;
----
1	Widget A
2	Widget B
5	Tool Z

# ============================================================================
# Cleanup
# ============================================================================

statement ok
DROP TABLE sales;

statement ok
DROP TABLE products;

statement ok
DROP TABLE customers;
