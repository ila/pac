# name: test/sql/pac_bitslice_compiler_correlated_subqueries.test
# description: Test PAC bitslice compiler with correlated subqueries (semi-joins)
# group: [sql]

require pac

# Set up TPC-H schema with customer as privacy unit
statement ok
CREATE TABLE customer (
    c_custkey INTEGER PRIMARY KEY,
    c_name VARCHAR,
    c_address VARCHAR,
    c_nationkey INTEGER,
    c_phone VARCHAR,
    c_acctbal DECIMAL(15,2),
    c_mktsegment VARCHAR,
    c_comment VARCHAR
);

statement ok
CREATE TABLE orders (
    o_orderkey INTEGER PRIMARY KEY,
    o_custkey INTEGER,
    o_orderstatus VARCHAR,
    o_totalprice DECIMAL(15,2),
    o_orderdate DATE,
    o_orderpriority VARCHAR,
    o_clerk VARCHAR,
    o_shippriority INTEGER,
    o_comment VARCHAR,
    FOREIGN KEY (o_custkey) REFERENCES customer(c_custkey)
);

statement ok
CREATE TABLE lineitem (
    l_orderkey INTEGER,
    l_partkey INTEGER,
    l_suppkey INTEGER,
    l_linenumber INTEGER,
    l_quantity DECIMAL(15,2),
    l_extendedprice DECIMAL(15,2),
    l_discount DECIMAL(15,2),
    l_tax DECIMAL(15,2),
    l_returnflag VARCHAR,
    l_linestatus VARCHAR,
    l_shipdate DATE,
    l_commitdate DATE,
    l_receiptdate DATE,
    l_shipinstruct VARCHAR,
    l_shipmode VARCHAR,
    l_comment VARCHAR,
    PRIMARY KEY (l_orderkey, l_linenumber),
    FOREIGN KEY (l_orderkey) REFERENCES orders(o_orderkey)
);

# Insert test data
statement ok
INSERT INTO customer VALUES
    (1, 'Customer#1', 'Address1', 1, '111-111-1111', 1000.00, 'BUILDING', 'comment1'),
    (2, 'Customer#2', 'Address2', 1, '222-222-2222', 2000.00, 'AUTOMOBILE', 'comment2'),
    (3, 'Customer#3', 'Address3', 1, '333-333-3333', 3000.00, 'MACHINERY', 'comment3');

statement ok
INSERT INTO orders VALUES
    (1, 1, 'O', 100.00, '1993-07-15', '1-URGENT', 'Clerk#1', 0, 'comment1'),
    (2, 1, 'O', 200.00, '1993-08-01', '2-HIGH', 'Clerk#2', 0, 'comment2'),
    (3, 2, 'O', 300.00, '1993-07-20', '1-URGENT', 'Clerk#3', 0, 'comment3'),
    (4, 2, 'F', 400.00, '1993-08-15', '3-MEDIUM', 'Clerk#4', 0, 'comment4'),
    (5, 3, 'O', 500.00, '1993-09-01', '2-HIGH', 'Clerk#5', 0, 'comment5'),
    (6, 3, 'O', 600.00, '1992-12-15', '1-URGENT', 'Clerk#6', 0, 'comment6');

statement ok
INSERT INTO lineitem VALUES
    (1, 1, 1, 1, 10, 100.00, 0.05, 0.01, 'N', 'O', '1993-08-01', '1993-07-20', '1993-08-05', 'DELIVER IN PERSON', 'TRUCK', 'comment1'),
    (2, 2, 2, 1, 20, 200.00, 0.05, 0.01, 'N', 'O', '1993-08-10', '1993-08-05', '1993-08-15', 'TAKE BACK RETURN', 'MAIL', 'comment2'),
    (3, 3, 3, 1, 15, 150.00, 0.05, 0.01, 'N', 'O', '1993-07-25', '1993-07-22', '1993-07-28', 'DELIVER IN PERSON', 'RAIL', 'comment3'),
    (3, 4, 4, 2, 25, 250.00, 0.05, 0.01, 'N', 'O', '1993-07-30', '1993-07-25', '1993-08-02', 'NONE', 'SHIP', 'comment4'),
    (4, 5, 5, 1, 30, 300.00, 0.05, 0.01, 'R', 'F', '1993-08-20', '1993-08-18', '1993-08-25', 'COLLECT COD', 'FOB', 'comment5'),
    (5, 6, 6, 1, 35, 350.00, 0.05, 0.01, 'N', 'O', '1993-09-05', '1993-09-10', '1993-09-15', 'DELIVER IN PERSON', 'TRUCK', 'comment6');

# Configure PAC
statement ok
pragma add_pac_privacy_unit('customer');

statement ok
SET pac_join_elimination = true;

statement ok
set pac_seed = 42;

# Test correlated subquery with EXISTS (semi-join) - similar to TPC-H Q04
# This query finds order priorities for orders in a date range that have at least one lineitem
# where the commit date is before the receipt date (late commitment)
query II
SELECT
    o_orderpriority,
    count(*) AS order_count
FROM
    orders
WHERE
    o_orderdate >= CAST('1993-07-01' AS date)
    AND o_orderdate < CAST('1993-10-01' AS date)
    AND EXISTS (
        SELECT
            *
        FROM
            lineitem
        WHERE
            l_orderkey = o_orderkey
            AND l_commitdate < l_receiptdate)
GROUP BY
    o_orderpriority
ORDER BY
    o_orderpriority;
----
1-URGENT	2
2-HIGH	4
3-MEDIUM	NULL

# Test TPC-H Q17-style correlated subquery with aggregates in both outer and inner queries
# This tests the case where lineitem (FK-linked table) appears in both outer aggregate and inner aggregate
# Both aggregates should be transformed to PAC functions

# Create part table for Q17-style query
statement ok
CREATE TABLE part (
    p_partkey INTEGER PRIMARY KEY,
    p_name VARCHAR,
    p_mfgr VARCHAR,
    p_brand VARCHAR,
    p_type VARCHAR,
    p_size INTEGER,
    p_container VARCHAR,
    p_retailprice DECIMAL(15,2),
    p_comment VARCHAR
);

statement ok
INSERT INTO part VALUES
    (1, 'Part#1', 'Manufacturer#1', 'Brand#23', 'PROMO BURNISHED COPPER', 7, 'MED BOX', 10.00, 'comment1'),
    (2, 'Part#2', 'Manufacturer#2', 'Brand#13', 'SMALL PLATED BRASS', 1, 'SM CASE', 20.00, 'comment2'),
    (3, 'Part#3', 'Manufacturer#3', 'Brand#23', 'MEDIUM POLISHED TIN', 15, 'MED BOX', 15.00, 'comment3'),
    (4, 'Part#4', 'Manufacturer#4', 'Brand#34', 'STANDARD BURNISHED STEEL', 14, 'LG CASE', 25.00, 'comment4'),
    (5, 'Part#5', 'Manufacturer#5', 'Brand#23', 'ECONOMY ANODIZED STEEL', 40, 'MED BOX', 30.00, 'comment5'),
    (6, 'Part#6', 'Manufacturer#1', 'Brand#23', 'PROMO BURNISHED TIN', 3, 'MED BOX', 12.00, 'comment6');

# TPC-H Q17-style query: Calculate average yearly revenue for a specific brand/container
# where quantity is less than 20% of the average quantity for that part
# This has:
# - Outer aggregate: SUM(l_extendedprice) on lineitem
# - Inner aggregate: AVG(l_quantity) on lineitem with correlation on l_partkey
# Both aggregates operate on FK-linked table, so BOTH get PAC transformation
query I
SELECT
    CAST(sum(l_extendedprice) / 7.0 AS INTEGER) AS avg_yearly
FROM
    lineitem,
    part
WHERE
    p_partkey = l_partkey
    AND p_brand = 'Brand#23'
    AND p_container = 'MED BOX'
    AND l_quantity < (
        SELECT
            0.2 * avg(l_quantity)
        FROM
            lineitem
        WHERE
            l_partkey = p_partkey
    );
----
NULL

# Test correlated subqueries on FK-linked tables with PU table scanned
# This tests the fix where aggregates in correlated subqueries that scan FK-linked tables
# (like orders) should ALSO be transformed to PAC aggregates, not just the outer aggregate
# Query: For each customer segment, compute statistics using correlated subqueries on orders
query III
SELECT
    COUNT(*) as customer_count,
    AVG((SELECT COUNT(*)
         FROM orders
         WHERE o_custkey = c_custkey
           AND o_totalprice > 10000)) AS avg_high_value_orders,
    AVG((SELECT SUM(o_totalprice)
         FROM orders
         WHERE o_custkey = c_custkey
           AND YEAR(o_orderdate) = 1995)) AS avg_1995_total
FROM
    customer
WHERE
    c_mktsegment = 'BUILDING';
----
NULL	NULL	NULL
