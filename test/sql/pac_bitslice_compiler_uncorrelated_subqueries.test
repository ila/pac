# name: test/sql/pac_bitslice_compiler_uncorrelated_subqueries.test
# description: Test bitslice compiler with complex queries involving subqueries, joins, and projections (TPC-H Q7 and Q13 patterns)
# group: [sql]

require pac

statement ok
SET pac_seed = 42

statement ok
SET pac_deterministic_noise = true

statement ok
SET threads = 1

statement ok
SET pac_mi = 0

# Create TPC-H-like schema with proper PK-FK relationships
# This tests the compiler's ability to handle:
# - Multiple joins across several tables
# - Projections with date functions and arithmetic
# - Filters on multiple conditions including OR
# - Group by with multiple columns
# - Subqueries with LEFT JOIN (Q13 pattern)

# Nation table
statement ok
CREATE TABLE nation(
    n_nationkey INTEGER PRIMARY KEY,
    n_name VARCHAR,
    n_regionkey INTEGER
);

statement ok
INSERT INTO nation VALUES
    (0, 'FRANCE', 0),
    (1, 'GERMANY', 0),
    (2, 'JAPAN', 1),
    (3, 'CHINA', 1),
    (4, 'USA', 2);

# Customer table (Privacy Unit)
statement ok
CREATE TABLE customer(
    c_custkey INTEGER PRIMARY KEY,
    c_name VARCHAR,
    c_nationkey INTEGER,
    FOREIGN KEY (c_nationkey) REFERENCES nation(n_nationkey)
);

statement ok
INSERT INTO customer VALUES
    (1, 'Customer#001', 0),
    (2, 'Customer#002', 1),
    (3, 'Customer#003', 0),
    (4, 'Customer#004', 1),
    (5, 'Customer#005', 2),
    (6, 'Customer#006', 0),
    (7, 'Customer#007', 1),
    (8, 'Customer#008', 2);

# Supplier table
statement ok
CREATE TABLE supplier(
    s_suppkey INTEGER PRIMARY KEY,
    s_name VARCHAR,
    s_nationkey INTEGER,
    FOREIGN KEY (s_nationkey) REFERENCES nation(n_nationkey)
);

statement ok
INSERT INTO supplier VALUES
    (1, 'Supplier#001', 0),
    (2, 'Supplier#002', 1),
    (3, 'Supplier#003', 0),
    (4, 'Supplier#004', 1);

# Orders table
statement ok
CREATE TABLE orders(
    o_orderkey INTEGER PRIMARY KEY,
    o_custkey INTEGER,
    o_orderdate DATE,
    o_comment VARCHAR,
    FOREIGN KEY (o_custkey) REFERENCES customer(c_custkey)
);

statement ok
INSERT INTO orders VALUES
    (1, 1, '1995-03-15', 'regular'),
    (2, 2, '1995-06-20', 'urgent'),
    (3, 3, '1995-09-10', 'regular'),
    (4, 4, '1996-01-05', 'regular'),
    (5, 5, '1996-04-12', 'urgent'),
    (6, 1, '1996-07-18', 'regular'),
    (7, 2, '1995-11-22', 'regular'),
    (8, 3, '1996-03-30', 'urgent'),
    (9, 6, '1995-05-14', 'regular'),
    (10, 7, '1996-08-25', 'regular'),
    (11, 1, '1995-12-01', 'urgent'),
    (12, 8, '1996-02-17', 'regular');

# Lineitem table
statement ok
CREATE TABLE lineitem(
    l_orderkey INTEGER,
    l_linenumber INTEGER,
    l_suppkey INTEGER,
    l_quantity DECIMAL(15,2),
    l_extendedprice DECIMAL(15,2),
    l_discount DECIMAL(15,2),
    l_shipdate DATE,
    PRIMARY KEY (l_orderkey, l_linenumber),
    FOREIGN KEY (l_orderkey) REFERENCES orders(o_orderkey),
    FOREIGN KEY (l_suppkey) REFERENCES supplier(s_suppkey)
);

statement ok
INSERT INTO lineitem VALUES
    (1, 1, 1, 10.00, 1000.00, 0.05, '1995-03-20'),
    (1, 2, 2, 15.00, 1500.00, 0.10, '1995-03-22'),
    (2, 1, 2, 20.00, 2000.00, 0.05, '1995-06-25'),
    (3, 1, 1, 25.00, 2500.00, 0.00, '1995-09-15'),
    (4, 1, 3, 30.00, 3000.00, 0.10, '1996-01-10'),
    (5, 1, 4, 12.00, 1200.00, 0.05, '1996-04-15'),
    (6, 1, 1, 18.00, 1800.00, 0.00, '1996-07-20'),
    (7, 1, 2, 22.00, 2200.00, 0.05, '1995-11-25'),
    (8, 1, 3, 16.00, 1600.00, 0.10, '1996-04-05'),
    (9, 1, 1, 14.00, 1400.00, 0.05, '1995-05-18'),
    (10, 1, 4, 20.00, 2000.00, 0.00, '1996-08-28'),
    (11, 1, 2, 25.00, 2500.00, 0.10, '1995-12-05'),
    (12, 1, 3, 30.00, 3000.00, 0.05, '1996-02-20');

statement ok
PRAGMA add_pac_privacy_unit('customer');

# Test 1: TPC-H Q7-style query
# Tests: Multiple joins, date filtering, projections with date_part, arithmetic expressions, GROUP BY, ORDER BY
# This query computes revenue between pairs of nations for a given date range
query IIII
SELECT
    supp_nation,
    cust_nation,
    l_year,
    SUM(volume) AS revenue
FROM (
    SELECT
        n1.n_name AS supp_nation,
        n2.n_name AS cust_nation,
        CAST(date_part('year', l_shipdate) AS INTEGER) AS l_year,
        l_extendedprice * (1 - l_discount) AS volume
    FROM
        supplier,
        lineitem,
        orders,
        customer,
        nation n1,
        nation n2
    WHERE
        s_suppkey = l_suppkey
        AND o_orderkey = l_orderkey
        AND c_custkey = o_custkey
        AND s_nationkey = n1.n_nationkey
        AND c_nationkey = n2.n_nationkey
        AND ((n1.n_name = 'FRANCE' AND n2.n_name = 'GERMANY')
            OR (n1.n_name = 'GERMANY' AND n2.n_name = 'FRANCE'))
        AND l_shipdate BETWEEN CAST('1995-01-01' AS DATE) AND CAST('1996-12-31' AS DATE)
) AS shipping
GROUP BY
    supp_nation,
    cust_nation,
    l_year
ORDER BY
    supp_nation,
    cust_nation,
    l_year;
----
FRANCE	GERMANY	1996	5400.0000
GERMANY	FRANCE	1995	7200.0000

# Test 2: TPC-H Q13-style query
# Tests: Subquery with LEFT JOIN, COUNT with optional match, GROUP BY on outer query, nested aggregates
# This query counts orders per customer, including customers with no orders
query II
SELECT
    c_count,
    COUNT(*) AS custdist
FROM (
    SELECT
        c_custkey,
        COUNT(o_orderkey) AS c_count
    FROM
        customer
    LEFT OUTER JOIN orders ON
        c_custkey = o_custkey
        AND o_comment NOT LIKE '%urgent%'
    GROUP BY
        c_custkey
) AS c_orders
GROUP BY
    c_count
ORDER BY
    custdist DESC,
    c_count DESC;
----
0	4
2	2
4	1
NULL	1

# Test 3: TPC-H Q8-style query with CASE expression in outer aggregate
# Tests: Nested query with subquery projection, CASE expression, division of aggregates
# This query computes market share for a specific nation
query II
SELECT
    o_year,
    CAST(SUM(CASE WHEN nation = 'FRANCE' THEN volume ELSE 0 END) / SUM(volume) AS DECIMAL(5, 2)) AS mkt_share
FROM (
    SELECT
        CAST(date_part('year', o_orderdate) AS INTEGER) AS o_year,
        l_extendedprice * (1 - l_discount) AS volume,
        n2.n_name AS nation
    FROM
        supplier,
        lineitem,
        orders,
        customer,
        nation n1,
        nation n2
    WHERE
        s_suppkey = l_suppkey
        AND l_orderkey = o_orderkey
        AND o_custkey = c_custkey
        AND c_nationkey = n1.n_nationkey
        AND s_nationkey = n2.n_nationkey
        AND n1.n_name IN ('FRANCE', 'GERMANY')
        AND o_orderdate BETWEEN CAST('1995-01-01' AS DATE) AND CAST('1996-12-31' AS DATE)
) AS all_nations
GROUP BY
    o_year
ORDER BY
    o_year;
----
1995	1.00
1996	0.42


# Test 8: Q8 variation with different CASE condition
query II
SELECT
    o_year,
    SUM(CASE WHEN nation = 'GERMANY' THEN volume ELSE 0 END) AS germany_volume
FROM (
    SELECT
        CAST(date_part('year', o_orderdate) AS INTEGER) AS o_year,
        l_extendedprice * (1 - l_discount) AS volume,
        n2.n_name AS nation
    FROM
        supplier,
        lineitem,
        orders,
        customer,
        nation n1,
        nation n2
    WHERE
        s_suppkey = l_suppkey
        AND l_orderkey = o_orderkey
        AND o_custkey = c_custkey
        AND c_nationkey = n1.n_nationkey
        AND s_nationkey = n2.n_nationkey
        AND o_orderdate >= CAST('1995-01-01' AS DATE)
        AND o_orderdate <= CAST('1996-12-31' AS DATE)
) AS all_nations
GROUP BY
    o_year
ORDER BY
    o_year;
----
1995	0.0000
1996	0.0000

# Test 4: TPC-H Q9-style query with complex arithmetic in subquery
# Tests: Subquery with multiple joins, complex arithmetic expression (subtraction of products), GROUP BY multiple columns
# This query computes profit by nation and year
query III
SELECT
    nation,
    o_year,
    SUM(amount) AS sum_profit
FROM (
    SELECT
        n_name AS nation,
        CAST(date_part('year', o_orderdate) AS INTEGER) AS o_year,
        l_extendedprice * (1 - l_discount) - l_quantity * 100 AS amount
    FROM
        supplier,
        lineitem,
        orders,
        customer,
        nation
    WHERE
        s_suppkey = l_suppkey
        AND o_orderkey = l_orderkey
        AND o_custkey = c_custkey
        AND s_nationkey = n_nationkey
        AND o_orderdate BETWEEN CAST('1995-01-01' AS DATE) AND CAST('1996-12-31' AS DATE)
) AS profit
GROUP BY
    nation,
    o_year
ORDER BY
    nation,
    o_year DESC;
----
FRANCE	1996	-300.0000
FRANCE	1995	-140.0000
GERMANY	1996	0.0000
GERMANY	1995	-420.0000

# Test 5: TPC-H Q15-style query with CTE and subquery computing max from CTE
# Tests: CTE with aggregate, subquery that computes max() from CTE (no base tables in subquery's scope)
# This is the pattern that was causing binding errors - aggregate in subquery should NOT be converted to pac_max
# because it operates on already-aggregated CTE data, not on base tables with privacy units
query IIII
WITH revenue AS (
    SELECT
        l_suppkey AS supplier_no,
        SUM(l_extendedprice * (1 - l_discount)) AS total_revenue
    FROM
        lineitem
            JOIN orders ON lineitem.l_orderkey = orders.o_orderkey
    WHERE
        l_shipdate >= CAST('1996-01-01' AS DATE)
        AND l_shipdate < CAST('1996-04-01' AS DATE)
    GROUP BY
        l_suppkey
)
SELECT
    s_suppkey,
    s_name,
    total_revenue,
    NULL as placeholder
FROM
    supplier
        JOIN revenue ON s_suppkey = supplier_no
WHERE
    total_revenue = (
        SELECT max(total_revenue)
        FROM revenue
    )
ORDER BY
    s_suppkey;
----
3	Supplier#003	5700.0000	NULL

# Clean up
statement ok
DROP TABLE lineitem;

statement ok
DROP TABLE orders;

statement ok
DROP TABLE supplier;

statement ok
DROP TABLE customer;

statement ok
DROP TABLE nation;
