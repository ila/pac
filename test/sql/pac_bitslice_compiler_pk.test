# name: test/sql/pac_bitslice_compiler_pk.test
# description: Test bitslice compiler queries when privacy-unit tables have primary keys (single & composite)
# group: [sql]

require pac

# Create two tables with 25 rows each and 5 groups (grp = i % 5)
# Single-column primary key
statement ok
CREATE TABLE bitslice_pk_single(
    id INTEGER PRIMARY KEY,
    grp INTEGER,
    val INTEGER,
    grp2 INTEGER
);

statement ok
INSERT INTO bitslice_pk_single
SELECT i AS id, i % 5 AS grp, (i % 10) AS val, (i % 3) AS grp2
FROM range(25) t(i);

# Composite primary key (three columns)
statement ok
CREATE TABLE bitslice_pk_many(
    pk1 INTEGER,
    pk2 INTEGER,
    pk3 INTEGER,
    grp INTEGER,
    val INTEGER,
    PRIMARY KEY(pk1, pk2, pk3)
);

statement ok
INSERT INTO bitslice_pk_many
SELECT i AS pk1, (i % 7) AS pk2, (i % 11) AS pk3, i % 5 AS grp, (i % 10) AS val
FROM range(25) t(i);

statement ok
pRAGMA add_pac_privacy_unit('bitslice_pk_single');

statement ok
pRAGMA add_pac_privacy_unit('bitslice_pk_many');

statement ok
set pac_seed = 42;

# 1) Ungrouped SUM on single-PK table (should match distribution from no-pk test)
query I
SELECT SUM(val) FROM bitslice_pk_single
----
123

# 2) GROUP BY on single-PK table (same expected group results)
query II
SELECT grp, SUM(val)
FROM bitslice_pk_single
GROUP BY grp
ORDER BY grp
----
0	15
1	21
2	22
3	22
4	43

# 2b) Multiple aggregates (SUM and COUNT) on single-PK table
query III
SELECT grp, SUM(val), COUNT(val)
FROM bitslice_pk_single
GROUP BY grp
ORDER BY grp
----
0	15	5
1	21	7
2	22	5
3	22	4
4	43	4

# 3) GROUP BY on composite-PK table (non-projected PKs)
query II
SELECT grp, SUM(val)
FROM bitslice_pk_many
GROUP BY grp
ORDER BY grp
----
0	10
1	15
2	15
3	17
4	30

# 4) Projecting the PKs while aggregating (group by PKs => per-row sums)
query II
SELECT id, SUM(val)
FROM bitslice_pk_single
GROUP BY id
ORDER BY id
LIMIT 3
----
0	0
1	1
2	4

query IIII
SELECT pk1, pk2, pk3, SUM(val)
FROM bitslice_pk_many
WHERE pk1 < 1
GROUP BY pk1, pk2, pk3
ORDER BY pk1
LIMIT 3
----
0	0	0	0

statement ok
PRAGMA remove_pac_privacy_unit('bitslice_pk_single');

# 5) JOIN aggregation (no GROUP BY)
query I
SELECT SUM(a.val)
FROM bitslice_pk_single a JOIN bitslice_pk_many b ON a.grp = b.grp
----
475

# ========== LEFT JOIN TEST CASES ==========

# Test LEFT JOIN with composite PK table on left
query III
SELECT b.grp, COUNT(*), SUM(COALESCE(a.val, 0))
FROM bitslice_pk_many b
LEFT JOIN bitslice_pk_single a ON b.grp = a.grp
GROUP BY b.grp
ORDER BY b.grp
----
0	15	50
1	20	75
2	20	100
3	30	100
4	15	150

# Test LEFT JOIN with aggregate on right table (composite PK)
query III
SELECT a.grp, SUM(a.val), COUNT(b.pk1)
FROM bitslice_pk_single a
LEFT JOIN bitslice_pk_many b ON a.grp = b.grp AND b.grp > 2
GROUP BY a.grp
ORDER BY a.grp
----
0	20	0
1	30	0
2	40	0
3	100	30
4	150	15

# Test multiple LEFT JOINs with PK tables
query II
SELECT a.grp, SUM(a.val)
FROM bitslice_pk_single a
LEFT JOIN bitslice_pk_many b ON a.grp = b.grp
LEFT JOIN bitslice_pk_single c ON a.grp2 = c.grp2
GROUP BY a.grp
ORDER BY a.grp
LIMIT 3
----
0	425
1	635
2	810

# Test RIGHT JOIN with composite PK table on right, aggregating with condition
query III
SELECT b.grp, COUNT(*), SUM(COALESCE(a.val, 0))
FROM bitslice_pk_single a
RIGHT JOIN bitslice_pk_many b ON a.grp = b.grp AND a.val > 3
GROUP BY b.grp
ORDER BY b.grp
----
0	6	50
1	8	60
2	8	70
3	12	64
4	15	150

# Cleanup
statement ok
DROP TABLE bitslice_pk_single

statement ok
DROP TABLE bitslice_pk_many
